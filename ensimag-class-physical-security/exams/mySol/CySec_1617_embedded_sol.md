# CySec Exam 2016/2017 - Embedded systems

## Q1 - Why is security in embedded system important? Cite a few domains where embedded systems should be secured, and describe at least an example of an embedded system that was compromised.

Security in embedded systems is crucial for several reasons:

1. **Sensitive Data Protection**: Many embedded systems handle sensitive information like personal data, financial details, or intellectual property. Security breaches can lead to data theft or manipulation.

2. **Control over Physical Systems**: Embedded systems often have direct control over physical operations in critical infrastructure, vehicles, or medical devices. Compromises can have real-world consequences, including damage and endangerment of lives.

3. **Widespread Use and Connectivity**: With the proliferation of IoT (Internet of Things), embedded systems are increasingly interconnected and remotely accessible, making them attractive targets for cyberattacks.

4. **Resource Constraints**: Embedded systems often have limited computing resources, making traditional security measures challenging to implement.

5. **Longevity and Lack of Updates**: Many embedded systems have long operational lifetimes, with limited opportunities for security updates, making them vulnerable to evolving threats.

**Domains Where Security of Embedded Systems is Essential:**

1. **Healthcare**: Medical devices like pacemakers, insulin pumps, and hospital monitoring systems contain embedded systems where security breaches can have life-threatening implications.

2. **Automotive Industry**: Modern vehicles, including connected and autonomous cars, are controlled by numerous embedded systems. Security flaws can lead to scenarios like unauthorized access or control over vehicle functions.

3. **Industrial Control Systems**: These systems operate in sectors like power generation, water treatment, and manufacturing. Compromises here can lead to massive disruptions and environmental damage.

4. **Consumer Electronics**: Devices like smartphones, smart home systems, and personal gadgets contain embedded systems that manage significant amounts of personal data.

5. **Financial Services**: ATMs and point-of-sale systems, which are embedded systems, handle financial transactions and sensitive banking information.

**Example of a Compromised Embedded System:**

- **Stuxnet Worm Attack (2010)**: One of the most notable examples of an embedded system compromise is the Stuxnet worm.
It targeted PLCs (Programmable Logic Controllers) used in Iran's nuclear facilities. Stuxnet subtly altered the operation of centrifuges while displaying normal operating parameters to monitoring systems.
This attack demonstrated how cyber threats could cause physical damage to industrial systems and highlighted the importance of securing embedded systems against sophisticated threats.

## Q2 - Power consumption and ElectroMagnetic emissions can be very sensitive in a secure application: why, and how do they differ? Which countermeasures can be adopted?

Power consumption and electromagnetic (EM) emissions are critical concerns in secure applications for several reasons, and they differ in how they can be exploited in attacks and how they are mitigated.

**Why They Are Sensitive:**

1. **Side-Channel Leakage**: Both power consumption and EM emissions can inadvertently leak information about the internal operations of a device. This leakage is exploited in side-channel attacks to extract sensitive information, such as cryptographic keys, without needing to break the actual encryption algorithms.

2. **Non-Invasive Nature**: Both types of attacks are non-invasive, meaning they donâ€™t require alteration of the device's hardware. This makes them particularly insidious, as they can be performed without leaving physical traces.

**How They Differ:**

1. **Power Consumption**:
   - **Mechanism of Leakage**: Power consumption varies based on the computational activities of the device. For example, different instructions and different data processed by a CPU can lead to observable variations in power consumption.
   - **Attack Method**: Power Analysis attacks, like Simple Power Analysis (SPA) and Differential Power Analysis (DPA), are common methods that analyze these variations to deduce sensitive information.

2. **Electromagnetic Emissions**:
   - **Mechanism of Leakage**: EM emissions are generated by the electronic activities within a device. The movement of electrical charges in circuits (especially high-frequency operations) generates detectable EM waves.
   - **Attack Method**: EM analysis involves capturing and analyzing these emissions, which can be done at a distance, making it more covert.

**Countermeasures:**

1. **For Power Consumption**:
   - **Balanced Hardware Design**: Design circuits such that their power consumption is independent of the processed data. For instance, using constant-current circuits.
   - **Randomized Execution**: Introduce randomness in the execution of operations to obscure the power consumption patterns.
   - **Voltage and Frequency Hopping**: Regularly changing the operating voltage and frequency can make power analysis more difficult.

2. **For Electromagnetic Emissions**:
   - **Shielding**: Use EM shielding materials around sensitive parts of the hardware to reduce emissions.
   - **Signal Suppression**: Design circuits that minimize high-frequency signals or use techniques like spread-spectrum clocking to distribute EM emissions over a wider range of frequencies.
   - **Physical Tamper Resistance**: Implement design features that make it harder to place EM probes close to the device without detection.

**Common Countermeasures**:
- **Security by Obscurity**: Hiding critical paths or operations within the device can make it harder for an attacker to know where to focus their analysis.
- **Noise Injection**: Adding random noise to the power supply or EM emissions can mask the leakage.

**Conclusion:**
While the countermeasures for power consumption and EM emissions have some overlap, they also require specific strategies tailored to the nature of the leakage. A layered approach, combining multiple countermeasures, is often most effective in enhancing the security of sensitive applications.

## Q3 - Describe how test structures may constitute a vulnerability for secure systems, and which solutions can be adopted to avoid the problem.

Test structures in secure systems can inadvertently become vulnerabilities due to several reasons. Originally designed to facilitate the manufacturing process, quality control, and fault diagnostics, these test structures can offer attackers unintended access points or information leakage channels.

**Vulnerabilities Introduced by Test Structures:**

1. **Information Leakage**: Test structures like scan chains and Built-In Self-Test (BIST) mechanisms can reveal internal states of the system, including sensitive data or cryptographic keys.

2. **Unauthorized Access**: Features like JTAG (Joint Test Action Group) interfaces, which are meant for debugging and testing, can be exploited to gain unauthorized access to the system, modify its behavior, or inject malicious code.

3. **Bypassing Security Mechanisms**: Test modes or special diagnostic states might bypass standard operational security controls, offering attackers an easier path to compromise the system.

**Solutions to Mitigate These Vulnerabilities:**

1. **Disable or Remove Test Features Post-Manufacturing**: One approach is to physically disable or permanently remove test structures after manufacturing. This can be done through fuses or one-time programmable (OTP) memory.

2. **Access Control Mechanisms**: Implement strict access control for test interfaces. For example, using password protection or cryptographic authentication to access JTAG ports.

3. **Secure Test Mode Entry**: Design the system such that entering a test or diagnostic mode requires a secure authentication process, and ensure that these modes have limited capabilities and do not expose sensitive information.

4. **Test Data Obfuscation**: Encrypt or scramble the data used in and produced by test structures to prevent direct leakage of sensitive information.

5. **Physical Countermeasures**: Employ tamper-detection mechanisms that can sense and respond to unauthorized physical access attempts, including attempts to access test interfaces.

6. **Design for Security**: Integrate security considerations into the design of test structures. This includes designing test access mechanisms that inherently minimize security risks.

7. **Regular Security Audits and Testing**: Conduct security audits and penetration testing that specifically target test and debug features to identify and mitigate potential vulnerabilities.

8. **Selective Functionality in Test Modes**: Limit the functionality available when the system is in test or debug mode, especially functions that can alter security-critical operations or data.

In summary, while test structures are essential for the manufacturing and maintenance of electronic systems, they must be carefully managed to ensure they do not become vulnerabilities in secure systems. The key is to balance the need for testing and diagnostics with the requirement to protect sensitive data and functionalities, applying a combination of hardware modifications, access control, and secure design practices.

## Q4 - Describe the steps to define and implement an error detecting code to protect a secure implementation against fault attacks. Which are the pro and the against of this technique?

To define and implement an Error Detecting Code (EDC) for protecting a secure implementation against fault attacks, you need to follow a systematic approach. This approach ensures that the chosen EDC effectively mitigates the risks while considering the constraints and requirements of the system.

**Steps to Define and Implement an EDC:**

1. **Define Fault Model**: Understand the types of faults you're protecting against (e.g., single-bit errors, multi-bit errors, burst errors). This step is crucial for selecting an appropriate EDC.

2. **Evaluate System Constraints**: Consider the limitations of your system, including computational power, memory, bandwidth, and latency requirements. These constraints will influence the choice of EDC.

3. **Select an Appropriate EDC**: Based on the fault model and system constraints, choose an EDC. Common options include parity bits, cyclic redundancy checks (CRCs), Hamming codes, and Reed-Solomon codes. Each has its strengths and is suitable for different types of errors and system requirements.

4. **Design EDC Integration**: Plan how the EDC will be integrated into your system. This includes determining where checks will be performed, how errors will be reported, and how the system will respond to detected errors.

5. **Implement EDC**: Develop the code or hardware logic needed to compute, add, check, and respond to the EDC. This could be part of a software routine or embedded in hardware design.

6. **Test and Validate**: Rigorously test the EDC implementation to ensure it works as expected under various scenarios, including simulated fault conditions.

7. **Deploy and Monitor**: Once implemented, continually monitor the system's effectiveness in detecting errors and respond to any identified issues or limitations.

**Pros and Cons of Using EDC for Fault Attack Protection:**

**Pros:**
- **Increased Reliability**: EDCs can significantly improve the reliability of a system by detecting errors that may occur due to environmental factors or deliberate fault attacks.
- **Non-Intrusiveness**: Many EDCs can be implemented without major changes to the existing system architecture.
- **Flexibility**: There are various EDCs available, each suited to different types of systems and error models.

**Cons:**
- **Performance Overhead**: Calculating and checking EDCs can introduce computational overhead, potentially reducing system performance.
- **Complexity**: Implementing EDCs, especially more complex ones like Reed-Solomon codes, can add complexity to the system design and implementation.
- **Limited Error Detection**: Not all EDCs can detect every type of error. Some can only detect single-bit errors, while others may not be effective against burst errors without significant complexity.
- **False Positives/Negatives**: Incorrectly implemented or chosen EDCs might result in false positives (flagging errors where there are none) or false negatives (failing to detect actual errors).

In conclusion, the use of

EDCs for fault attack protection is a balance between enhancing system reliability and managing the additional complexity and performance overhead. The choice of EDC should align with the specific error model, system constraints, and the security requirements of the implementation. While EDCs can significantly improve fault resilience, they are not a panacea and should be part of a layered security approach, especially in high-security contexts. 

## Q5 - Define and describe Hardware Trojans.

Hardware Trojans are malicious modifications to the hardware of a device, often inserted during the design or manufacturing process, with the intent of causing harm, enabling unauthorized access, or performing secret functions. They can be inserted into integrated circuits (ICs), processors, peripheral devices, or any hardware components.

**Characteristics of Hardware Trojans:**

1. **Stealthy**: Hardware Trojans are designed to be difficult to detect. They often remain dormant until triggered by a specific condition or event, reducing the likelihood of discovery during routine testing.

2. **Diverse Activation Mechanisms**: The trigger for a Hardware Trojan can vary widely, from a specific input pattern to a certain date/time or even environmental conditions.

3. **Varied Payloads**: Once activated, the payload of a Hardware Trojan can do anything from leaking sensitive information, disabling or degrading the performance of the hardware, to completely destroying the device.

4. **Multiple Insertion Points**: Hardware Trojans can be introduced at various stages of the hardware development lifecycle, including design, fabrication, assembly, and even during firmware updates.

5. **Small Size**: To avoid detection, Hardware Trojans are often very small in comparison to the overall size of the circuitry, making them hard to detect with conventional testing methods.

**Types of Hardware Trojans:**

1. **Functional Trojans**: These modify the actual functionality of the hardware. For example, they might alter the behavior of a cryptographic module to leak keys.

2. **Parametric Trojans**: Instead of changing functionality, these alter parameters like power consumption or timing, which can lead to failures or reveal sensitive information through side-channel attacks.

3. **Fabrication Trojans**: Introduced during the IC fabrication process, possibly by altering the photomask or doping process.

4. **Assembly Trojans**: Introduced during the assembly of the hardware, such as by adding, removing, or replacing components.

**Detection and Mitigation:**

Detecting Hardware Trojans is challenging due to their stealthy nature. Techniques include:

- **Advanced Testing and Analysis**: Using specialized testing procedures, like side-channel analysis or reverse engineering, to detect anomalies.
- **Design for Trust**: Implementing measures in the design phase to make the insertion of Trojans more difficult or easier to detect.
- **Secure Supply Chain Management**: Ensuring the integrity of the hardware through trusted suppliers and secure logistics.
- **Regular Audits and Inspections**: Conducting thorough inspections and audits at various stages of the hardware lifecycle.

In conclusion, Hardware Trojans pose a significant security risk, especially in critical infrastructure and sensitive applications. Their detection and prevention require a combination of advanced technical measures, secure design practices, and vigilant supply chain management.
